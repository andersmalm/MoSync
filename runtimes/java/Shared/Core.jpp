/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#include "generated/gen-opcodes.h"
#include "helpers.h"
#include "core_helpers.h"
//#include "asm_config.h"
#include "Float.h"

import java.io.*;

#define CORE this

#ifdef GDB_DEBUG
#include "GdbStub.h"
#endif

final public class Core {
	STATIC int mMem_ds[];
	STATIC int mMEM_DS_SIZE;
	int STACK_BOTTOM;
	int STACK_TOP;

	Syscall mSyscall;

	MainCanvas mCanvas;

#ifdef GDB_DEBUG
	GdbStub mGdbStub;
#endif

	//***************************************************************************
	// Common
	//***************************************************************************

	public final void destruct() throws Exception {
		mSyscall.destruct();

#ifdef GDB_DEBUG
		mGdbStub.closeDebugConnection();
#endif
	}

	//***************************************************************************
	//Memory access
	//***************************************************************************
#ifdef DEBUG_MEMORY
#ifdef MOSYNC_STATIC_JAVA
#define DEBUG_ALWAYS_IP(a) DEBUG_ALWAYS(a +"\n")
#else
#define DEBUG_ALWAYS_IP(a) DEBUG_ALWAYS(a + " @ IP 0x"+Integer.toHexString(mIP)+"\n")
#endif

	final byte rbyte(int addr) THE {
		if(addr > (mMEM_DS_SIZE-1) || addr < 0) {
			DEBUG_ALWAYS_IP("ERROR: rbyte out of bounds (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		int shift = BYTEPART(addr) << 3;
		return (byte)((mMem_ds[INTPART(addr)] >> shift) & 0x0ff);
	}

	final void wbyte(int addr, byte b) THE {
		if(addr > (mMEM_DS_SIZE-1) || addr < 0) {
			DEBUG_ALWAYS_IP("ERROR: wbyte out of bounds (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		int shift = BYTEPART(addr) << 3;
		mMem_ds[INTPART(addr)] = (mMem_ds[INTPART(addr)] & ~(0x000000ff << shift)) |
			((((int)b) & 0x0ff) << shift);
	}

	final int rint(int addr) THE {
		if(addr > (mMEM_DS_SIZE-4) || addr < 0) {
			DEBUG_ALWAYS_IP("ERROR: rint out of bounds (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		if(BYTEPART(addr) != 0) {
			DEBUG_ALWAYS_IP("ERROR: rint alignment error (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		return mMem_ds[INTPART(addr)];
	}

	final void wint(int addr, int i) THE {
		if(addr > (mMEM_DS_SIZE-4) || addr < 0) {
			DEBUG_ALWAYS_IP("ERROR: wint out of bounds (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		if(BYTEPART(addr) != 0) {
			DEBUG_ALWAYS_IP("ERROR: wint alignment error (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		mMem_ds[INTPART(addr)] = i;
	}

	final short rshort(int addr) THE {
		if(addr > (mMEM_DS_SIZE-2) || addr < 0) {
			DEBUG_ALWAYS_IP("ERROR: rshort out of bounds (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		if((addr & 1) != 0) {
			DEBUG_ALWAYS_IP("ERROR: rshort alignment error (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		int shift = BYTEPART(addr) << 3;
		return (short)((mMem_ds[INTPART(addr)] >> shift) & (0xffff));
	}

	final void wshort(int addr, short s) THE {
		if(addr > (mMEM_DS_SIZE-2) || addr < 0) {
			DEBUG_ALWAYS_IP("ERROR: wshort out of bounds (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		if((addr & 1) != 0) {
			DEBUG_ALWAYS_IP("ERROR: WSHORT alignment error (0x"+Integer.toHexString(addr)+")");
			BIG_PHAT_ERROR;
		}
		int shift = BYTEPART(addr) << 3;
		mMem_ds[INTPART(addr)] = (mMem_ds[INTPART(addr)] & ~(0x0000ffff << shift)) |
			((((int)s) & (0xffff)) << shift);
	}
#endif	//DEBUG_MEMORY

	int GetValidatedStackValue(int offset) {
		int address = mRegs[REG_sp] + offset;
		if(((address & 0x03) != 0) || (address) < STACK_BOTTOM || (address) > STACK_TOP) {
#ifdef DEBUG_MEMORY
			DEBUG_ALWAYS_IP("ERROR: stack access error (0x"+Integer.toHexString(address)+")");
#endif	//DEBUG_MEMORY
			BIG_PHAT_ERROR;
		}
		address >>= 2;
		return mMem_ds[address];
	}

	//***************************************************************************
	// Static
	//***************************************************************************

#ifdef MOSYNC_STATIC_JAVA
	StaticCode mStaticCode = new StaticCode();

	public Core(MainCanvas aCanvas, String resname) throws Exception {
		mCanvas = aCanvas;
		mSyscall = new Syscall(this, aCanvas);
		DEBUG_ASSERT(mStaticCode != null);
		mMem_ds = StaticCode.mem_ds;
		DEBUG_ASSERT(mMem_ds != null);
		mMEM_DS_SIZE = mMem_ds.length << 2;

		DEBUG_ASSERT(mSyscall != null);

		InputStream resources = GET_RESOURCE(resname);
		if(resources == null) {
			mSyscall.LoadResources(null, null);
		} else {
			LittleEndianDataInputStream llis = new LittleEndianDataInputStream(resources);
			mSyscall.LoadResources(llis, resname);
			llis.close();
		}
	}

	public void run() {
		mStaticCode.run(mSyscall);
	}

	public void interrupt() {
		//won't work 100%. example MoSync code: while(1);
		mStaticCode.mem_ds = null;
		mStaticCode.syscall = null;
	}
#else
	//***************************************************************************
	// Dynamic
	//***************************************************************************

#define MA_HEAD_MAGIC 0x5944414d	//MADY

#define _MA_HEAD(m)\
	m(int, Magic)\
	m(int, CodeLen)\
	m(int, DataLen)\
	m(int, DataSize)\
	m(int, StackSize)\
	m(int, HeapSize)\
	m(int, CtorAddress)\
	m(int, DtorAddress)\
	m(int, BuildID)\
	m(int, AppID)\
	m(int, EntryPoint)\

#define DEFINE_HEAD_VAR(type, name) STATIC type Head_##name;
	_MA_HEAD(DEFINE_HEAD_VAR);

	//all member variables have 'm' prefix and (sorta) camel case.
	STATIC byte mMem_cs[];
	STATIC int mMem_cp[];

	STATIC int mRegs[];
	STATIC DOUBLE mFregs[];

	STATIC int mIP;
	STATIC boolean mVM_Yield;
#ifndef PHONE_RELEASE
	STATIC public int mInstCount = 0;
#endif
	//public long mEndTime;

#ifdef PUBLIC_DEBUG
	int mLastSyscall = INVALID_SYSCALL_NUMBER;
#endif

	public Core(MainCanvas aCanvas, String modname, String resname) throws Exception {
		mCanvas = aCanvas;
		mSyscall = new Syscall(this, aCanvas);

		DEBUG_ASSERT(mSyscall != null);

		{
			LittleEndianDataInputStream llis =
				new LittleEndianDataInputStream(GET_RESOURCE(modname));
			LoadVMApp(llis);
			llis.close();
		}

		InputStream resources = GET_RESOURCE(resname);
		if(resources == null) {
			mSyscall.LoadResources(null, null);
		} else {
			LittleEndianDataInputStream llis = new LittleEndianDataInputStream(resources);
			mSyscall.LoadResources(llis, resname);
			llis.close();
		}
	}

	public Core(MainCanvas aCanvas, InputStream programStream) throws Exception {
		mCanvas = aCanvas;
		mSyscall = new Syscall(this, aCanvas);

		LittleEndianDataInputStream file = new LittleEndianDataInputStream(programStream);
		LoadVMApp(file);
		if(file.available()==0) {
			mSyscall.LoadResources(null, null);
		} else {
			mSyscall.LoadResources(file, null);
		}
	}


	//***************************************************************************
	//Initialization
	//***************************************************************************

	final int nextPowerOf2(int min, int x) {	//arguments are assumed to be positive
		int i = min;
		while(i < x) {
			i <<= 1;
		}
		return i;
	}
#ifdef MA_PROF_SUPPORT_JAVAPACKAGE_LOCATIONAPI
	int mCustomEventPointer;
#endif
	int mCustomMemPointer;

	final void LoadVMApp(LittleEndianDataInputStream file) throws Exception {
		InitVM();
		LoadVM(file);
		int[] regs = mRegs;

		mCustomMemPointer = mMEM_DS_SIZE;

#ifdef MA_PROF_SUPPORT_OPENGL_ES
		/*
		mSyscall.maGLInit();
		String [] openglStrings = mSyscall.readOpenglStrings();
		Syscall.maGLClose();

		int totalOpenglStringSize = 0;
		for(int i = 0; i < openglStrings.length; i++) totalOpenglStringSize += openglStrings[i].length()+1;
		mSyscall.mOpenglStringsPointers = new int[openglStrings.length];
		mCustomMemPointer -= totalOpenglStringSize;
		int ptr = mCustomMemPointer;
		for(int i = 0; i < openglStrings.length; i++) {
			mSyscall.mOpenglStringsPointers[i] = ptr;
			for(int j = 0; j < openglStrings[i].length(); j++) {
				wbyte(ptr++, (byte)openglStrings[i].charAt(j));
			}
			wbyte(ptr++, (byte)0);
		}
		*/
#endif

		// Init regs + IP

#ifdef MA_PROF_SUPPORT_JAVAPACKAGE_LOCATIONAPI
		//allocate space for location event structs
		mCustomEventPointer = mCustomMemPointer - MALOCATION_INT_COUNT * 4;
		regs[REG_sp] = mCustomEventPointer - 16;
#else
		regs[REG_sp] = mCustomMemPointer - 16;
#endif
		regs[REG_p0] = mMEM_DS_SIZE;
		regs[REG_p1] = Head_StackSize;
		regs[REG_p2] = Head_HeapSize;
		regs[REG_p3] = Head_CtorAddress;
		regs[REG_g0] = Head_DtorAddress;
		DDUMP(Head_EntryPoint);
		mIP = Head_EntryPoint;

		STACK_TOP = regs[REG_sp];
		STACK_BOTTOM = STACK_TOP-Head_StackSize;
	}

	final void InitVM()
#ifdef GDB_DEBUG
		throws Exception
#endif
	{
		mVM_Yield = false;

		mRegs = new int[NREGS];
		mFregs = new DOUBLE[NFREGS];

#ifdef MA_PROF_SUPPORT_CLDC_10
		for(int i=0; i<NFREGS; i++) {
			mFregs[i] = new Real();
		}
#endif

#ifdef _DEBUG
		DEBUG("Regs:\n");
		for(int i=0; i<NREGS; i++) {
			DEBUG(""+i+": 0x"+Integer.toHexString(mRegs[i])+"("+mRegs[i]+")\n");
		}
		DEBUG("\n");
#endif

#ifdef GDB_DEBUG
		mGdbStub = new GdbStub(this);
		mGdbStub.setupDebugConnection();
#endif
	}

	void LoadVM(LittleEndianDataInputStream file) throws Exception {
		try {
			if(file.available() == 0) {
				BIG_PHAT_ERROR;
			}

#define HEAD_READ_VAR(type, name) Head_##name = file.CAP_##type(read)();\
	DDUMP(Head_##name);

			DEBUG_LOAD("Load Header\n");
			_MA_HEAD(HEAD_READ_VAR);

			if(Head_Magic != MA_HEAD_MAGIC) {
				DEBUG_ALWAYS("Magic error: 0x"+Integer.toHexString(Head_Magic)+" should be "+Integer.toHexString(MA_HEAD_MAGIC)+"\n");
				BIG_PHAT_ERROR;
			}

			DEBUG_LOAD("Load Code ("+Head_CodeLen+" bytes)\n");
			DEBUG_ASSERT(Head_CodeLen > 0);
			mMem_cs = new byte[Head_CodeLen];

			file.readFully(mMem_cs);

			mMEM_DS_SIZE = nextPowerOf2(64*1024, Head_DataSize);
			DUMP(mMEM_DS_SIZE);
			MYASSERT((mMEM_DS_SIZE & 3) == 0);
			int[] mem_ds = mMem_ds = new int[mMEM_DS_SIZE >> 2];

			DEBUG_LOAD("Load Data ("+Head_DataLen+" bytes)\n");
			if(Head_DataLen > 0) {
				int intpart = INTPART(Head_DataLen);
				for(int i=0; i<intpart; i++) { // Load data
					mem_ds[i] = file.readInt();
				}
				for(int i=0; i<BYTEPART(Head_DataLen); i++) {
					WBYTE((intpart << 2) + i, (byte)file.read());
				}
			}
		} catch(IOException e) {
			PRINT_STACK_TRACE;
			BIG_PHAT_ERROR;
		}
	}

	//***************************************************************************
	//Misc
	//***************************************************************************

	void yield() {
		mVM_Yield = true;
		Thread.yield();
	}

	/*boolean timeToClose() {
		if(G_CLOSING)
			if(System.currentTimeMillis() >= mEndTime) {
				mCanvas.SetExit(-1);
				return true;
			}
		return false;
	}*/

	//***************************************************************************
	//Syscalls
	//***************************************************************************
#include "syscall_converters.h"

#ifndef MA_PROF_SUPPORT_CLDC_10
#if 0	//unused
	double ints2double(int hiw, int low) {
		//DEBUG_SC("("+hiw+","+low+")->");
		//DEBUG_SC("("+UINT(low)+")");
		long l = (((long)hiw) << 32) | UINT(low);
		double d = Double.longBitsToDouble(l);
		debug_double(l, d);
		return d;
	}
#endif
#endif

	final void InvokeSysCall(int type) throws Exception {
		int[] regs = mRegs;
		DOUBLE[] fregs = mFregs;
#ifdef PUBLIC_DEBUG
		mLastSyscall = type;
#endif

#define CALL_SYSCALL(name) mSyscall.name
#define MACString Address
#define CMACString Address
#define MAOUT(type) Address
#define MAIN(type) type
		switch(type) {
#include "generated/invoke_syscall_java.h"
		default:  //bad syscall
			DEBUG_ALWAYS("bad syscall: "+type+"\n");
			BIG_PHAT_ERROR;
		}
	}

#define EXEC_NAME run
#define EXEC_LOOP while(true)
#define EXEC_RETURN
#include "core_run.h"
#undef EXEC_NAME
#undef EXEC_LOOP
#undef EXEC_RETURN

#ifdef GDB_DEBUG
#define EXEC_NAME step
#define EXEC_LOOP
#define EXEC_RETURN return IP;
#include "core_run.h"
#undef EXEC_NAME
#undef EXEC_LOOP
#undef EXEC_RETURN
#endif	//GDB_DEBUG

	// System.arraycopy is the fastest way to implement memset() in JavaME.
	// We start with one byte and exponentially increase the length of the copies.
	public static void bytefill(byte[] array, byte value) {
		int len = array.length;
		if (len > 0)
			array[0] = value;
		for (int i = 1; i < len; i += i)
			System.arraycopy(array, 0, array, i, ((len - i) < i) ? (len - i) : i);
	}

	public void interrupt() {
		//set all instructions to BREAK
		bytefill(mMem_cs, (byte)OP_BREAK);
	}

	private static final char[] digits = {
		'0','1','2','3','4','5','6','7',
		'8','9','a','b','c','d','e','f',
	};

	public static String unsignedLongToHexString(long i) {
		char[] buf = new char[64];
		int charPos = 64;
		do {
			 buf[--charPos] = digits[(int)(i & 0xf)];
			 i >>>= 4;
		} while (i != 0);
		buf[--charPos] = 'x';
		buf[--charPos] = '0';
		return new String(buf, charPos, (64 - charPos));
	}

#endif	//MOSYNC_STATIC_JAVA
/*
	static
	{
		System.loadLibrary("mosync");
	}
*/
}

#ifdef MOSYNC_STATIC_JAVA
final class StaticCode
{
	static int __dbl_high;
	static Syscall syscall;
	static int mem_ds[];
	void run(Syscall s) {}
}
#endif
